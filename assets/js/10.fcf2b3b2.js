(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{282:function(v,e,_){"use strict";_.r(e);var t=_(14),l=Object(t.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"redis基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis基础"}},[v._v("#")]),v._v(" Redis基础")]),v._v(" "),e("h3",{attrs:{id:"数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),e("h4",{attrs:{id:"string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[v._v("#")]),v._v(" String")]),v._v(" "),e("ul",[e("li",[v._v("计数器")]),v._v(" "),e("li",[v._v("统计数")]),v._v(" "),e("li",[v._v("对象缓存存储")])]),v._v(" "),e("h4",{attrs:{id:"list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[v._v("#")]),v._v(" List")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("list命令都以L/R开头")])]),v._v(" "),e("li",[e("p",[v._v("lpush [name] [v1] [v2] [v2]\t(栈)")])]),v._v(" "),e("li",[e("p",[v._v("lrange [name] 0 -1")])]),v._v(" "),e("li",[e("p",[v._v("rpush [name] [v1]")])]),v._v(" "),e("li",[e("p",[v._v("lpop")])]),v._v(" "),e("li",[e("p",[v._v("rpop")])]),v._v(" "),e("li",[e("p",[v._v("lindex [name] [index]\t通过下表获取值")])]),v._v(" "),e("li",[e("p",[v._v("llen 获取list长度")])]),v._v(" "),e("li",[e("p",[v._v("lrem [listname] [nums] [elem] 移除nums个elem (精确匹配)")])]),v._v(" "),e("li",[e("p",[v._v("ltrim [listname]  start stop  截取指定长度")])]),v._v(" "),e("li",[e("p",[v._v("rpoplpush")])]),v._v(" "),e("li",[e("p",[v._v("lset 将列表中指定下标的值替换为另外一个值，更新操作")])]),v._v(" "),e("li",[e("p",[v._v("linsert   将某个具体的value插入到列把你中某个元素的前面或者后面！")]),v._v(" "),e("ul",[e("li",[v._v("他实际上是一个链表，before Node after ， left，right 都可以插入值")]),v._v(" "),e("li",[v._v("如果key 不存在，创建新的链表")]),v._v(" "),e("li",[v._v("如果key存在，新增内容")]),v._v(" "),e("li",[v._v("如果移除了所有值，空链表，也代表不存在！")]),v._v(" "),e("li",[v._v("在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~")]),v._v(" "),e("li",[v._v("消息排队!消息队列(Lpush Rpop),栈(Lpush Lpop)")])])])]),v._v(" "),e("p",[v._v("List阻塞队列")]),v._v(" "),e("h4",{attrs:{id:"set-不能重复-无序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set-不能重复-无序"}},[v._v("#")]),v._v(" Set(不能重复,无序)")]),v._v(" "),e("ul",[e("li",[v._v("sadd key member[member ...]")]),v._v(" "),e("li",[v._v("smembers key")]),v._v(" "),e("li",[v._v("sismember key member")]),v._v(" "),e("li",[v._v("scard myset")]),v._v(" "),e("li",[v._v("srem key member")]),v._v(" "),e("li",[v._v("srandmember key")]),v._v(" "),e("li",[v._v("spop key")]),v._v(" "),e("li",[v._v("smove source destination membe")]),v._v(" "),e("li",[v._v("sinter key [key …] 查看一个集合的全部成员，该集合是所有给定集合的交集。\t[共同好友,共同爱好,二度好友的实现]")]),v._v(" "),e("li",[v._v("sunion key [key …] 查看一个集合的全部成员，该集合是所有给定集合的并集。")]),v._v(" "),e("li",[v._v("sdiff key [key …] 查看所有给定 key 与第一个 key 的差集")])]),v._v(" "),e("h4",{attrs:{id:"hash"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[v._v("#")]),v._v(" Hash")]),v._v(" "),e("p",[v._v("hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ hash 更适合于对象的 存储，String更加适合字符串存储！")]),v._v(" "),e("ul",[e("li",[v._v("hset key field value  set一个具体 key-vlaue")]),v._v(" "),e("li",[v._v("hget key field")]),v._v(" "),e("li",[v._v("hmset key field value")]),v._v(" "),e("li",[v._v("hmget key field")]),v._v(" "),e("li",[v._v("hgetall key")]),v._v(" "),e("li",[v._v("hdel key field")]),v._v(" "),e("li",[v._v("hlen key")]),v._v(" "),e("li",[v._v("hexists key field")]),v._v(" "),e("li",[v._v("hkeys key")]),v._v(" "),e("li",[v._v("hvals key")]),v._v(" "),e("li",[v._v("hincrby key field num")]),v._v(" "),e("li",[v._v("hsetnx key field value")]),v._v(" "),e("li")]),v._v(" "),e("h4",{attrs:{id:"zset-有序集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zset-有序集合"}},[v._v("#")]),v._v(" Zset(有序集合)")]),v._v(" "),e("ul",[e("li",[v._v("zadd key")]),v._v(" "),e("li",[v._v("zrangebyscore key min max\n1， 重要消息 2，带权重进行判断！ 排行榜应用实现，取Top N 测试！")])]),v._v(" "),e("h4",{attrs:{id:"geospatial-地理位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#geospatial-地理位置"}},[v._v("#")]),v._v(" geospatial(地理位置)")]),v._v(" "),e("p",[v._v("定位,\n附近的人,(获得所有附近人的地址,定位),通过半径查询\n打车计算距离")]),v._v(" "),e("ul",[e("li",[v._v("geoadd 添加位置\n"),e("ul",[e("li",[v._v("规则:两极无法添加,下载城市数据,直接通过java导入")]),v._v(" "),e("li",[v._v("参数:key 值[经度,纬度 名称]")])])]),v._v(" "),e("li",[v._v("geodist 两个给定位置之间的距离")]),v._v(" "),e("li",[v._v("geohash 返回一个或多个位置元素的 Geohash 表示")]),v._v(" "),e("li",[v._v("geopos 获取指定城市的经纬度")]),v._v(" "),e("li",[v._v("georadius  以给定的经纬度为中心,找出某一半径内的元素")]),v._v(" "),e("li",[v._v("georadiusbymember  找出位于指定元素周围的其他元素")])]),v._v(" "),e("p",[v._v("GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo")]),v._v(" "),e("h4",{attrs:{id:"hyperloglog"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hyperloglog"}},[v._v("#")]),v._v(" hyperloglog")]),v._v(" "),e("p",[v._v("基数---不重复的元素\n优点：占用的内存是固定，2^64 不同的元素的技术，只需要废 12KB内存！如果要从内存角度来比较的 话 Hyperloglog 首选！"),e("br"),v._v("\n页面的访问量(一个人访问网站多次,但还是算一个人)"),e("br"),v._v("\n传统的方式: set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断"),e("br"),v._v("\n这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id； 0.81% 错误率！ 统计UV任务，可以忽略不计的！"),e("br"),v._v("\n如果允许容错，那么一定可以使用 Hyperloglog ！ 如果不允许容错，就使用 set 或者自己的数据类型即可!")]),v._v(" "),e("ul",[e("li",[v._v("pfadd key element")]),v._v(" "),e("li",[v._v("pfcount key")]),v._v(" "),e("li",[v._v("pfmerge destkey sourcekey")])]),v._v(" "),e("h4",{attrs:{id:"bitmaps"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bitmaps"}},[v._v("#")]),v._v(" bitmaps")]),v._v(" "),e("p",[v._v("位存储\n只有两个状态的都可以使用bitmaps,省内存操作二进制位来进行记录")]),v._v(" "),e("ul",[e("li",[v._v("setbit key offset value")]),v._v(" "),e("li",[v._v("getbit key offset")]),v._v(" "),e("li",[v._v("bitcount key")])]),v._v(" "),e("h3",{attrs:{id:"命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命令"}},[v._v("#")]),v._v(" 命令")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("可以用作数据库,缓存和消息中间件MQ")])]),v._v(" "),e("li",[e("p",[v._v("默认有16个数据库")])]),v._v(" "),e("li",[e("p",[v._v("默认使用第0个")])]),v._v(" "),e("li",[e("p",[v._v("select切换")])]),v._v(" "),e("li",[e("p",[v._v("dbsize 数据库大小")])]),v._v(" "),e("li",[e("p",[v._v("set name young")])]),v._v(" "),e("li",[e("p",[v._v("get name")])]),v._v(" "),e("li",[e("p",[v._v("查看Key数据类型")]),v._v(" "),e("ul",[e("li",[v._v("type [keyname]")])])]),v._v(" "),e("li",[e("p",[v._v("查看所有Key:")]),v._v(" "),e("ul",[e("li",[v._v("keys *")])])]),v._v(" "),e("li",[e("p",[v._v("删除key")]),v._v(" "),e("ul",[e("li",[v._v("del [keyname] [数据库序号]")])])]),v._v(" "),e("li",[e("p",[v._v("追加字符串")]),v._v(" "),e("ul",[e("li",[v._v('append [keyname] ["string"]')]),v._v(" "),e("li",[v._v("不存在,相当于setkey")])])]),v._v(" "),e("li",[e("p",[v._v("截取范围内字符串")]),v._v(" "),e("ul",[e("li",[v._v("getrange [keyname] [start] [end]")])])]),v._v(" "),e("li",[e("p",[v._v("替换指定范围")]),v._v(" "),e("ul",[e("li",[v._v("setrange [keyname] [offset] [value]")])])]),v._v(" "),e("li",[e("p",[v._v("字符串长度")]),v._v(" "),e("ul",[e("li",[v._v("strlen [keyname]")])])]),v._v(" "),e("li",[e("p",[v._v("key对应的值自增1")]),v._v(" "),e("ul",[e("li",[v._v("incr [keyname]")]),v._v(" "),e("li",[v._v("浏览量自增时使用")])])]),v._v(" "),e("li",[e("p",[v._v("key对应的值自增/减n")]),v._v(" "),e("ul",[e("li",[v._v("incrby [keyname] [n]")]),v._v(" "),e("li",[v._v("decrby [keyname] [n]")])])]),v._v(" "),e("li",[e("p",[v._v("key对应的值自减1")]),v._v(" "),e("ul",[e("li",[v._v("decr [keyname]")])])]),v._v(" "),e("li",[e("p",[v._v("移动某个Key到其他库")]),v._v(" "),e("ul",[e("li",[v._v("move [keyname] [db]")])])]),v._v(" "),e("li",[e("p",[v._v("设置过期时间")]),v._v(" "),e("ul",[e("li",[v._v("expire [keyname] 10")]),v._v(" "),e("li",[v._v("可用作单点登录设置过期时间")]),v._v(" "),e("li",[v._v("setex [keyname] [time] [value] (set with expire)")])])]),v._v(" "),e("li",[e("p",[v._v("不存在则设置")]),v._v(" "),e("ul",[e("li",[v._v("○ setnx (set if not exist) (分布式锁常用)")])])]),v._v(" "),e("li",[e("p",[v._v("批量设置(原子性操作,要么一起成功,要么一起失败)")]),v._v(" "),e("ul",[e("li",[v._v("mset [k1] [v1] [k2] [v2]- ○ mget [k1] [k2]")])])]),v._v(" "),e("li",[e("p",[v._v("查看剩余时间")]),v._v(" "),e("ul",[e("li",[v._v("ttl [keyname]")])])]),v._v(" "),e("li",[e("p",[v._v("清空当前库")]),v._v(" "),e("ul",[e("li",[v._v("flushdb")])])]),v._v(" "),e("li",[e("p",[v._v("清空所有库")]),v._v(" "),e("ul",[e("li",[v._v("flushall")])])]),v._v(" "),e("li",[e("p",[v._v("设置对象")]),v._v(" "),e("ul",[e("li",[v._v("mset user:1:name zhangsan user:1:age:3")])])]),v._v(" "),e("li",[e("p",[v._v("组合命令")]),v._v(" "),e("ul",[e("li",[v._v("getset(如果不存在,则返回nil,并设置;如果存在,获取原来的值,设置新的值)")])])]),v._v(" "),e("li",[e("p",[v._v("redis是单线程的,6.0后支持多线程")])]),v._v(" "),e("li",[e("p",[v._v("Redis的瓶颈是机器的内存和网络带宽")])])]),v._v(" "),e("p",[v._v("误区一：高性能服务器一定是多线程的"),e("br"),v._v("\n误区二：多线程(产生CPU上下文的切换)一定比单线程效率高"),e("br"),v._v("\nredis：将所有数据放到内存中,所以使用单线程操作效率高,多线程CPU上线文切换耗时高,对于内存系统来说,没有上下文切换,多次读写都是在一个CPU上.效率就是最高的.")]),v._v(" "),e("h3",{attrs:{id:"事务操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务操作"}},[v._v("#")]),v._v(" 事务操作")]),v._v(" "),e("h3",{attrs:{id:"线程模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程模型"}},[v._v("#")]),v._v(" 线程模型")]),v._v(" "),e("h3",{attrs:{id:"内存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[v._v("#")]),v._v(" 内存管理")]),v._v(" "),e("h3",{attrs:{id:"读写策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#读写策略"}},[v._v("#")]),v._v(" 读写策略")]),v._v(" "),e("h3",{attrs:{id:"持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[v._v("#")]),v._v(" 持久化")]),v._v(" "),e("h3",{attrs:{id:"内存碎片"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片"}},[v._v("#")]),v._v(" 内存碎片")]),v._v(" "),e("h2",{attrs:{id:"redis-conf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-conf"}},[v._v("#")]),v._v(" redis.conf")]),v._v(" "),e("h2",{attrs:{id:"订阅发布"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#订阅发布"}},[v._v("#")]),v._v(" 订阅发布")]),v._v(" "),e("h2",{attrs:{id:"主从复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从复制"}},[v._v("#")]),v._v(" 主从复制")]),v._v(" "),e("h2",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),e("h2",{attrs:{id:"分布式集群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式集群"}},[v._v("#")]),v._v(" 分布式集群")])])}),[],!1,null,null,null);e.default=l.exports}}]);