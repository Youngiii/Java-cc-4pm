(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{287:function(t,a,s){"use strict";s.r(a);var e=s(14),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"mysql45讲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql45讲"}},[t._v("#")]),t._v(" mysql45讲")]),t._v(" "),a("h2",{attrs:{id:"第03、08讲-事务隔离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第03、08讲-事务隔离"}},[t._v("#")]),t._v(" 第03、08讲 事务隔离")]),t._v(" "),a("p",[t._v("多个事务同时执行 会导致 --\x3e 脏读，不可重复读，幻读等问题")]),t._v(" "),a("h3",{attrs:{id:"隔离级别-解决脏读-幻读-不可重复读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别-解决脏读-幻读-不可重复读"}},[t._v("#")]),t._v(" 隔离级别（解决脏读，幻读，不可重复读）")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("读未提交")]),t._v(" ：一个事务还没提交时，它做的变更就能被别的事务看到。")]),t._v(" "),a("li",[a("strong",[t._v("读提交")]),t._v("：一个事务提交之后，它做的变更才会被其他事务看到。")]),t._v(" "),a("li",[t._v("**可重复读：**一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。")]),t._v(" "),a("li",[a("strong",[t._v("串行化")]),t._v("：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。")])]),t._v(" "),a("p",[t._v("配置隔离级别为 “读提交”")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'查看当前隔离级别'")]),t._v("\nmysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("show")]),t._v(" variables "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("like")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'transaction_isolation'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-----------------------+-----------------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Variable_name         "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Value")]),t._v("           "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-----------------------+-----------------+")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" transaction_isolation "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("REPEATABLE")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("READ")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-----------------------+-----------------+")]),t._v("\n")])])]),a("h3",{attrs:{id:"事务隔离的实现-多版本并发控制-mvcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离的实现-多版本并发控制-mvcc"}},[t._v("#")]),t._v(" 事务隔离的实现：多版本并发控制（MVCC）")]),t._v(" "),a("p",[t._v("每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通 过回滚操作，都可以得到前一个状态的值。\n"),a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22068508/1659332979409-c80ad8fa-818c-435f-a344-20d71dc64491.png#clientId=u4a1c72a4-1054-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=239&id=u9dc62519&margin=%5Bobject%20Object%5D&name=image.png&originHeight=646&originWidth=1178&originalType=binary&ratio=1&rotation=0&showTitle=false&size=354737&status=done&style=none&taskId=u933ac72a-c055-4ef1-9caf-69bdd97decb&title=&width=435",alt:"image.png"}}),t._v("\n长事务：存在很老的事务视图。大量占用存储空间，占用锁资源。")]),t._v(" "),a("h3",{attrs:{id:"事务启动方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务启动方式"}},[t._v("#")]),t._v(" 事务启动方式")]),t._v(" "),a("ol",[a("li",[t._v("显示启动：begin 或 start transaction 提交 commit 回滚 rollback")]),t._v(" "),a("li",[t._v("set autocommit = 0 不会自动提交")])]),t._v(" "),a("p",[t._v("建议：在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务。")]),t._v(" "),a("h3",{attrs:{id:"避免长事务对业务的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免长事务对业务的影响"}},[t._v("#")]),t._v(" 避免长事务对业务的影响")]),t._v(" "),a("ul",[a("li",[t._v("开发端\n"),a("ol",[a("li",[t._v("确认是否使用了set autocommit=0。把MySQL的 general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。")]),t._v(" "),a("li",[t._v("确认是否有不必要的只读事务。")]),t._v(" "),a("li",[t._v("根据业务本身的预估，通过SETMAX_EXECUTION_TIME命令， 来控制每个语句执行的最长时间")])])]),t._v(" "),a("li",[t._v("数据库端\n"),a("ol",[a("li",[t._v("监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill;")]),t._v(" "),a("li",[t._v("Percona的pt-kill")]),t._v(" "),a("li",[t._v("在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题;")]),t._v(" "),a("li",[t._v("如果使用的是MySQL5.6或者更新版本，把innodb_undo_tablespaces设置成2(或更大的 值)。")])])])]),t._v(" "),a("h3",{attrs:{id:"事务隔离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离"}},[t._v("#")]),t._v(" 事务隔离")]),t._v(" "),a("ul",[a("li",[t._v("数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。")])]),t._v(" "),a("p",[t._v("InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建 快照”的能力。")]),t._v(" "),a("ul",[a("li",[t._v("更新数据都是先读后写的，而这个读，只能读当前的 值，称为“当前读”(current read)。")])]),t._v(" "),a("p",[t._v("一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以 外，有三种情况:")]),t._v(" "),a("ol",[a("li",[t._v("版本未提交，不可见;")]),t._v(" "),a("li",[t._v("版本已提交，但是是在视图创建后提交的，不可见;")]),t._v(" "),a("li",[t._v("版本已提交，而且是在视图创建前提交的，可见。")])]),t._v(" "),a("h2",{attrs:{id:"第04、05、09讲-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第04、05、09讲-索引"}},[t._v("#")]),t._v(" 第04、05、09讲 索引")]),t._v(" "),a("p",[t._v("索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。")]),t._v(" "),a("h3",{attrs:{id:"常见模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见模型"}},[t._v("#")]),t._v(" 常见模型")]),t._v(" "),a("ul",[a("li",[t._v("哈希表")])]),t._v(" "),a("p",[t._v("哈希+链表，适用于只有等值查询的场景。如memcached及其他nosql引擎。")]),t._v(" "),a("ul",[a("li",[t._v("有序数组")])]),t._v(" "),a("p",[t._v("数组，适用于等值查询和范围查询，静态存储引擎。更新效率不高。")]),t._v(" "),a("ul",[a("li",[t._v("搜索树")]),t._v(" "),a("li",[t._v("跳表")]),t._v(" "),a("li",[t._v("LSM树")])]),t._v(" "),a("p",[t._v("数据库底层存储的核心就是基于这些数据模型的。\n在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。")]),t._v(" "),a("h3",{attrs:{id:"innodb索引模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb索引模型"}},[t._v("#")]),t._v(" InnoDB索引模型")]),t._v(" "),a("p",[t._v("每一个索引在InnoDB里面对应一棵B+树。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。\n建表语句：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("primary")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("key")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  k "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("not")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("engine")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("InnoDB")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("根据叶子节点的内容，索引类型分为主键索引(聚簇索引)和非主键索引（二级索引）。")]),t._v(" "),a("ul",[a("li",[t._v("主键索引的叶子节点存的是整行数据")]),t._v(" "),a("li",[t._v("非主键索引的叶子节点内容是主键的值，基于非主键索引的查询需要多扫描一棵索引树。（回表）")])]),t._v(" "),a("h3",{attrs:{id:"索引维护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引维护"}},[t._v("#")]),t._v(" 索引维护")]),t._v(" "),a("p",[t._v("页分裂。性能受到影响。数据页的利用率收到影响。\n页合并。\n解决：\n创建一个"),a("strong",[t._v("自增主键")]),t._v("，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。\n这样非主键索引占用的空间最小。主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。")]),t._v(" "),a("h3",{attrs:{id:"回表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回表"}},[t._v("#")]),t._v(" 回表")]),t._v(" "),a("p",[t._v("回到主键索引树搜索的过程，我们称为回表。\n由于查询结果所需要的数据只在主键索引上有，所以不得不回表。")]),t._v(" "),a("h3",{attrs:{id:"覆盖索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[t._v("#")]),t._v(" 覆盖索引")]),t._v(" "),a("p",[t._v("索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。\n由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用 的性能优化手段。\n索引字段的维护总是有代价的，在建立冗余索引来支持覆盖索引时就需要权衡考虑。")]),t._v(" "),a("h3",{attrs:{id:"最左前缀原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最左前缀原则"}},[t._v("#")]),t._v(" 最左前缀原则")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/22068508/1659505363279-f2b6ceaf-5a96-48a5-b222-77e015015054.png#clientId=ue247b6ed-ab97-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=259&id=u9522ba46&margin=%5Bobject%20Object%5D&name=image.png&originHeight=726&originWidth=1238&originalType=binary&ratio=1&rotation=0&showTitle=false&size=980656&status=done&style=none&taskId=u0dcc2a8d-71b8-4a7c-8f94-5674ae9e59e&title=&width=441",alt:"image.png"}}),t._v(" "),a("code",[t._v("where name like ‘张%’")]),t._v("，查找到第一个符合条件的记录是ID3，然后向后遍历， 直到不满足条件为止。")]),t._v(" "),a("blockquote",[a("p",[t._v("联合索引如何安排索引顺序？")])]),t._v(" "),a("p",[t._v("优先考虑索引的复用能力。\n其次考虑空间。")]),t._v(" "),a("h3",{attrs:{id:"索引下推"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引下推"}},[t._v("#")]),t._v(" 索引下推")]),t._v(" "),a("p",[t._v("有联合索引："),a("code",[t._v("(name,age)")]),t._v("\nSQL语句："),a("code",[t._v("select * from tuser where name like '张%' and age = 10 and ismale = 1;")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v('"张" 找到 ID3')])]),t._v(" "),a("li"),t._v(" "),a("li",[a("p",[t._v("5.6之前 ：回表，对比字段值")])]),t._v(" "),a("li",[a("p",[t._v("5.6之后 ：索引下推，索引遍历过程中，对索引包含的字段做判断，直接过滤掉不满足条件的记录。减少回表次数。")])])]),t._v(" "),a("h3",{attrs:{id:"普通索引和唯一索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通索引和唯一索引"}},[t._v("#")]),t._v(" 普通索引和唯一索引")]),t._v(" "),a("p",[a("strong",[t._v("查询过程")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("普通索引：查到满足条件的第一个记录后，需要查找下一个记录，直到碰到不满足条件的记录。")]),t._v(" "),a("li",[t._v("唯一索引：查到第一个满足条件的记录后，停止继续检索。")])]),t._v(" "),a("p",[t._v("性能差距：微乎其微。\n原因：InnoDB引擎是按数据页为单位来读写的。\n"),a("strong",[t._v("change buffer")]),t._v("：数据页更新时，若内存中有则直接更新，若没有，将更新操作缓存在change buffer中，查询需要访问数据页时，将数据页读入内存，然后执行change buffer中缓存的相关操作来保证数据的正确性。\n"),a("strong",[t._v("merge触发机制")]),t._v("：1. 访问数据页时 2. 后台线程定期merge 3. shutdown时\n"),a("strong",[t._v("大小设置")]),t._v("：change buffer用的是buffer pool里的内存，可以通过innodb_change_buffer_max_size参数设置，设置为50时，表示change buffer的大小最多只能占用buffer pool的50%。\n"),a("strong",[t._v("适用场景")]),t._v("：写多读少。原因：一次merge之前，change buffer记录的变更越多，收益越大。\n若一次更新后伴随查询，则不应该使用，IO次数不会减少反而增加change buffer维护代价。\n"),a("strong",[t._v("更新过程：")]),t._v("\n唯一索引下，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。所以没必要使用change buffer。\n情况一：这个记录要更新的目标页在内存中。")]),t._v(" "),a("ul",[a("li",[t._v("唯一索引：找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束;")]),t._v(" "),a("li",[t._v("普通索引：找到3和5之间的位置，插入这个值，语句执行结束。")])]),t._v(" "),a("p",[t._v("情况二：要更新的目标页不在内存中。")]),t._v(" "),a("ul",[a("li",[t._v("唯一索引：需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束。")]),t._v(" "),a("li",[t._v("普通索引：将更新记录在change buffer，语句执行结束。")])]),t._v(" "),a("p",[a("strong",[t._v("change buffer和redo log：")]),t._v("\nredo log将随机写IO转换成顺序写IO，change buffer是减少随机读IO的消耗。")]),t._v(" "),a("h3",{attrs:{id:"选错索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选错索引"}},[t._v("#")]),t._v(" 选错索引")]),t._v(" "),a("p",[t._v("原因：优化器没能准确判断出"),a("strong",[t._v("扫描行数")]),t._v("。\n扫描行数的判断：索引的“区分度”，即索引上不同值的个数（基数）。个数越多区分度越好。\n基数计算：采样统计。\n解决：\n"),a("code",[t._v("analyze table t")]),t._v("：重新统计索引信息")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("force index(a) ：让优化器强制使用a索引")])]),t._v(" "),a("li",[t._v("修改语句")]),t._v(" "),a("li",[t._v("新建一个更合适的索引，或删掉误用的索引。")])]),t._v(" "),a("h3",{attrs:{id:"字符串字段加索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串字段加索引"}},[t._v("#")]),t._v(" 字符串字段加索引")]),t._v(" "),a("ul",[a("li",[t._v("创建完整索引")]),t._v(" "),a("li",[t._v("前缀索引：区分度越高，效果越好")])]),t._v(" "),a("p",[t._v("使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。\n使用前缀索引就用不上覆盖索引对查询性能的优化\n区分度不够时：")]),t._v(" "),a("ul",[a("li",[t._v("倒序存储")]),t._v(" "),a("li",[t._v("使用hash字段：新建整数字段，保存校验码，同时在字段上建立索引，插入时先得到校验码填入这个新字段。由于存在冲突，所以查询where部分需要同时判断id_card是否相同。")])]),t._v(" "),a("h2",{attrs:{id:"第06、07讲-全局锁、表锁、行锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第06、07讲-全局锁、表锁、行锁"}},[t._v("#")]),t._v(" 第06、07讲 全局锁、表锁、行锁")]),t._v(" "),a("h3",{attrs:{id:"全局锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[t._v("#")]),t._v(" 全局锁")]),t._v(" "),a("p",[t._v("定义：对整个数据库实例加锁。\n两种方式：")]),t._v(" "),a("ul",[a("li",[t._v("FLUSH TABLES WRITE READ LOCK")]),t._v(" "),a("li",[t._v("set global readonly=true")])]),t._v(" "),a("p",[t._v("建议FTWRL方式\n原因：")]),t._v(" "),a("ol",[a("li",[t._v("readonly可能被用来做其他判断，比如主从库。")]),t._v(" "),a("li",[t._v("异常处理机制差异：readonly异常时会保持readonly状态，导致长时间不可写。FTWRL异常时，mysql会自动释放全局锁。\n使用场景：全库逻辑备份。\n只读状态危险（不加–single-transaction时）：\n主库备份：不能更新，业务停摆\n从库备份：从库不能执行binlog，导致主从延迟\n"),a("strong",[t._v("官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性快照视图")]),t._v("。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。")])]),t._v(" "),a("h3",{attrs:{id:"表级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[t._v("#")]),t._v(" 表级锁")]),t._v(" "),a("ul",[a("li",[t._v("表锁 （不支持行锁时才会用到）")])]),t._v(" "),a("p",[t._v("语法：加锁、lock tables ...read/write ；释放、unlock tables\n注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。")]),t._v(" "),a("ul",[a("li",[t._v("元数据锁（meta date lock，MDL）")])]),t._v(" "),a("p",[t._v("在访问一个表的时候会被自动加上，当对一个表做增删改查操作的时候，加MDL读锁;当要对表做结构变更操作的时候，加MDL写锁。")]),t._v(" "),a("ul",[a("li",[t._v("读锁之间不互斥")]),t._v(" "),a("li",[t._v("读写锁之间，写锁之间互斥，保证表更表结构操作的安全性。")])]),t._v(" "),a("p",[t._v("如何安全地给小表加字段?")]),t._v(" "),a("ol",[a("li",[t._v("解决长事务，暂停或kill掉。MySQL的information_schema 库的 innodb_trx表中可以查询正在执行的事务。")]),t._v(" "),a("li",[t._v("若是热点表，请求频繁，kill不掉。考虑在alter table语句里面 设定等待时间。能拿到MDL写锁最好，拿不到先放弃，之后用重试命令重复过程。")])]),t._v(" "),a("h3",{attrs:{id:"行锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[t._v("#")]),t._v(" 行锁")]),t._v(" "),a("p",[t._v("由各个引擎自己实现。MyISAM不支持行锁，Innodb支持。\n在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是"),a("strong",[t._v("两阶段锁")]),t._v("协议。\n所以，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。\n死锁：\n并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致 这几个线程都进入无限等待的状态，称为死锁。\n出现死锁后的策略：")]),t._v(" "),a("ul",[a("li",[t._v("直接进入等待，直到超时。超时时间可以通过参数 innodb_lock_wait_timeout来设置。默认开启且时间为50s。")]),t._v(" "),a("li",[t._v("（推荐）发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事 务得以继续执行。将参数innodb_deadlock_detect设置为on（默认为on），表示开启这个逻辑。")])]),t._v(" "),a("p",[t._v("解决热点行更新导致对的性能问题（假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级 ）：")]),t._v(" "),a("ul",[a("li",[t._v("确保不会出现死锁的前提下，临时关掉死锁检测。")]),t._v(" "),a("li",[t._v("控制并发度。")])]),t._v(" "),a("h2",{attrs:{id:"第12讲-刷脏页"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第12讲-刷脏页"}},[t._v("#")]),t._v(" 第12讲 刷脏页")]),t._v(" "),a("p",[t._v("脏页（内存数据页跟磁盘数据页内容不一致的时候） --\x3e flush（把内存里的数据写入磁盘的过程） --\x3e干净页（内存和磁盘上的数据页的内容一致）\n"),a("strong",[t._v("flush触发时机")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("innoDB的redo log写满了")]),t._v(" "),a("li",[t._v("系统内存不足")]),t._v(" "),a("li",[t._v("系统空闲时期")]),t._v(" "),a("li",[t._v("mysql正常关闭时")])]),t._v(" "),a("p",[t._v("InnoDB用缓冲池 (buffer pool)管理内存，"),a("strong",[t._v("缓冲池中的内存页有三种状态")]),t._v(":\n第一种是，还没有使用的;\n第二种是，使用了并且是干净页;\n第三种是，使用了并且是脏页。\n"),a("strong",[t._v("刷脏页影响性能情况：")])]),t._v(" "),a("ol",[a("li",[t._v("一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长;")]),t._v(" "),a("li",[t._v("日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。")])]),t._v(" "),a("p",[a("strong",[t._v("InnoDB刷脏页控制策略：")]),t._v(" "),a("code",[t._v("innodb_io_capacit")]),t._v(" 值设置为磁盘的IOPS  ： 让磁盘全力刷脏页\n磁盘的IOPS可以通过fio工具测试\n"),a("strong",[t._v("Innodb刷盘速度")]),t._v("：脏页比例 + redo log写盘速度")]),t._v(" "),a("ol",[a("li",[t._v("innodb根据脏页比例根据算法计算出一个值，根据日志序号和checkpoint的差值根据算法计算一个值，取两者较大的记为R")]),t._v(" "),a("li",[t._v("innodb按照R% * innodb_io_capacity")])]),t._v(" "),a("h2",{attrs:{id:"第13讲-数据库表的空间回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第13讲-数据库表的空间回收"}},[t._v("#")]),t._v(" 第13讲 数据库表的空间回收")]),t._v(" "),a("p",[t._v("innodb表 = 表结构定义 + 数据\n8.0以前：表结构存在.frm文件里\n8.0之后：表结构系统数据表中")]),t._v(" "),a("h3",{attrs:{id:"参数innodb-file-per-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数innodb-file-per-table"}},[t._v("#")]),t._v(" 参数innodb_file_per_table")]),t._v(" "),a("p",[t._v("作用：控制表数据存在 共享表空间（off） or 成为一个单独.ibd文件（on）\n5.6以后 默认为on。（推荐）")]),t._v(" "),a("ul",[a("li",[t._v("更容易管理。")]),t._v(" "),a("li",[t._v("且通过drop命令可以删除文件。如果为off，表删除掉，空间并不会回收。")])]),t._v(" "),a("h3",{attrs:{id:"数据删除流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据删除流程"}},[t._v("#")]),t._v(" 数据删除流程")]),t._v(" "),a("p",[t._v("delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件 的大小是不会变的。并且数据页的复用跟记录的复用是不同的。不止是删除数据会造成空洞，插入数据也会。\n结论：大量增删改的表，都可能存在空洞。")]),t._v(" "),a("h3",{attrs:{id:"重建表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重建表"}},[t._v("#")]),t._v(" 重建表")]),t._v(" "),a("p",[t._v("5.6之前：alter table A engine=InnoDB ；会造成数据丢失。\n5.6之后：online DDL；重建表过程中，允许做增删改操作。")]),t._v(" "),a("p",[t._v("如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是 不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。")]),t._v(" "),a("p",[t._v("在重建表的时候，InnoDB不会把整张表占满，每个页留了1/16给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。")]),t._v(" "),a("h2",{attrs:{id:"第14讲-count"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第14讲-count"}},[t._v("#")]),t._v(" 第14讲 count(*)")]),t._v(" "),a("p",[t._v("count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。")]),t._v(" "),a("h3",{attrs:{id:"count-实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#count-实现方式"}},[t._v("#")]),t._v(" count(*)实现方式")]),t._v(" "),a("ul",[a("li",[t._v("MyISAM 总行数存在了磁盘上，直接返回")]),t._v(" "),a("li",[t._v("InnoDB 一行一行读，然后累计计数")])]),t._v(" "),a("p",[t._v("由于MVCC的存在，同一时刻的多个查询，InnoDB表“应该返回多少行”的个数也是不确定的。\n所以只能一行一行依次读进行判断。\n优化：\nMySQL优化器会找到最小的那棵树来遍历。在保证逻辑正 确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。\n总结：")]),t._v(" "),a("ul",[a("li",[t._v("MyISAM表虽然count(*)很快，但是不支持事务;")]),t._v(" "),a("li",[t._v("show table status命令虽然返回很快，但是不准确;")]),t._v(" "),a("li",[t._v("InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。")])]),t._v(" "),a("h3",{attrs:{id:"自己计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自己计数"}},[t._v("#")]),t._v(" 自己计数")]),t._v(" "),a("ul",[a("li",[t._v("缓存系统保存计数（Redis：可能会丢失更新")]),t._v(" "),a("li",[t._v("数据库保存计数（把计数直接放到数据库里单独的一张计数表C中")])]),t._v(" "),a("h2",{attrs:{id:"第20讲-幻读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第20讲-幻读"}},[t._v("#")]),t._v(" 第20讲 幻读")]),t._v(" "),a("ul",[a("li",[t._v("for update：在查询时,对这条数据进行加锁,避免其他用户以该表进行插入,修改或删除等操作,造成表的不一致性.")])]),t._v(" "),a("p",[t._v("当前读。能读到所有已经提交的记录的最新值。\nInnoDB默认是行级别的锁，当有明确指定的主键时候，是行级锁。否则是表级别。")]),t._v(" "),a("ul",[a("li",[t._v("在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。")]),t._v(" "),a("li",[t._v("幻读仅专指“"),a("strong",[t._v("新插入的行")]),t._v("”。")])]),t._v(" "),a("h3",{attrs:{id:"幻读的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#幻读的问题"}},[t._v("#")]),t._v(" 幻读的问题")]),t._v(" "),a("ul",[a("li",[t._v("语义破坏")]),t._v(" "),a("li",[t._v("数据一致性")])]),t._v(" "),a("h3",{attrs:{id:"解决-间隙锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决-间隙锁"}},[t._v("#")]),t._v(" 解决--间隙锁")]),t._v(" "),a("p",[t._v("原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。\n间隙锁：跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。\n间隙锁+行锁 = next- key lock 一个前开后闭区间\n间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。\n间隙锁是在可重复读隔离级别下才会生效。\n如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置 为row。这也是现在不少公司使用的配置组合。")]),t._v(" "),a("h2",{attrs:{id:"第22讲-饮鸠止渴-提高性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第22讲-饮鸠止渴-提高性能"}},[t._v("#")]),t._v(" 第22讲 ‘饮鸠止渴’提高性能")]),t._v(" "),a("h3",{attrs:{id:"短链接风暴"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#短链接风暴"}},[t._v("#")]),t._v(" 短链接风暴")]),t._v(" "),a("p",[t._v("mysql建立连接需要：网络连接三次握手，登录权限判断，获得读写权限。\n连接数上限：max_connections参数；超过时会拒绝连接。\n连接数暴涨时：")]),t._v(" "),a("ol",[a("li",[t._v("处理掉占着连接但是不工作的线程。")])]),t._v(" "),a("ul",[a("li",[t._v("事先设置wait_timeout（空闲wait_timeout秒后直接断开连接）")]),t._v(" "),a("li",[t._v("show processlist踢掉显示为sleep的线程\n"),a("ul",[a("li",[t._v("注意⚠️：查information_schema库的innodb_trx表（当前运行的所有事务）。先踢掉不在此表的线程。")])])])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("减少连接过程的消耗。")])]),t._v(" "),a("ul",[a("li",[t._v("跳过权限验证：重启数据库，并使用-skip-grant-tables参数启动。")])]),t._v(" "),a("h3",{attrs:{id:"慢查询性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慢查询性能问题"}},[t._v("#")]),t._v(" 慢查询性能问题")]),t._v(" "),a("h4",{attrs:{id:"索引没有设计好"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引没有设计好"}},[t._v("#")]),t._v(" 索引没有设计好")]),t._v(" "),a("ul",[a("li",[t._v("紧急创建索引（主库A、备库B）\n"),a("ul",[a("li",[t._v("备库B执行set sql_log_bin=off; alter table；")]),t._v(" "),a("li",[t._v("主备切换")]),t._v(" "),a("li",[t._v("备库A执行相同语句")])])]),t._v(" "),a("li",[t._v("gh-ost")])]),t._v(" "),a("h4",{attrs:{id:"sql语句没写好-18讲提到的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql语句没写好-18讲提到的情况"}},[t._v("#")]),t._v(" SQL语句没写好（18讲提到的情况）")]),t._v(" "),a("ul",[a("li",[t._v("query_rewrite插件（可以把输入的一种语句改写成另外一种模式）")])]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 目的")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 改为")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" t "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 插入一条规则（注：我这张表在 employees 库中）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("insert")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("into")]),t._v(" query_rewrite"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rewrite_rules"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pattern"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" replacement"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pattern_database"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("values")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"select * from t where id + 1 = ? "')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"select * from t where id = ? - 1 "')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"employees"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("call")]),t._v(" query_rewrite"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("flush_rewrite_rules"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 查询规则表")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" query_rewrite"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("rewrite_rules"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h4",{attrs:{id:"mysql选错索引-10讲提到的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql选错索引-10讲提到的情况"}},[t._v("#")]),t._v(" Mysql选错索引（10讲提到的情况）")]),t._v(" "),a("ul",[a("li",[t._v("使用查询重写功能，加上force index")])]),t._v(" "),a("h4",{attrs:{id:"如何避免"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免"}},[t._v("#")]),t._v(" 如何避免")]),t._v(" "),a("ul",[a("li",[t._v("测试环境把慢查询日志 show log打开且 long_query_time = 0，确保每个语句都会被记录")]),t._v(" "),a("li",[t._v("模拟线上数据，做一遍回归测试")]),t._v(" "),a("li",[t._v("观察慢查询日志的输出，特别留意rows_examined字段是否与预期一致。")])]),t._v(" "),a("h3",{attrs:{id:"qps突增问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#qps突增问题"}},[t._v("#")]),t._v(" QPS突增问题")])])}),[],!1,null,null,null);a.default=r.exports}}]);