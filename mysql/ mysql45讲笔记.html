<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>mysql45讲 | Java-cc-4pm</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="yee的学习笔记">
    
    <link rel="preload" href="/Java-cc-4pm/assets/css/0.styles.5f2da5a7.css" as="style"><link rel="preload" href="/Java-cc-4pm/assets/js/app.b4fa842c.js" as="script"><link rel="preload" href="/Java-cc-4pm/assets/js/2.eeb24f79.js" as="script"><link rel="preload" href="/Java-cc-4pm/assets/js/14.275ba392.js" as="script"><link rel="prefetch" href="/Java-cc-4pm/assets/js/10.fcf2b3b2.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/11.b7afb852.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/12.da36e819.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/13.9449ceac.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/15.f9855d75.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/3.b155d814.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/4.f876ad59.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/5.18c5236f.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/6.e86df8f9.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/7.3039bb28.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/8.b2c83167.js"><link rel="prefetch" href="/Java-cc-4pm/assets/js/9.6a457fac.js">
    <link rel="stylesheet" href="/Java-cc-4pm/assets/css/0.styles.5f2da5a7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Java-cc-4pm/" class="home-link router-link-active"><!----> <span class="site-name">Java-cc-4pm</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Java-cc-4pm/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记本" class="dropdown-title"><span class="title">笔记本</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记本" class="mobile-dropdown-title"><span class="title">笔记本</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java-cc-4pm/mysql/" class="nav-link router-link-active">
  mysql
</a></li><li class="dropdown-item"><!----> <a href="/Java-cc-4pm/Java/" class="nav-link">
  Java
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Java-cc-4pm/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记本" class="dropdown-title"><span class="title">笔记本</span> <span class="arrow down"></span></button> <button type="button" aria-label="笔记本" class="mobile-dropdown-title"><span class="title">笔记本</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java-cc-4pm/mysql/" class="nav-link router-link-active">
  mysql
</a></li><li class="dropdown-item"><!----> <a href="/Java-cc-4pm/Java/" class="nav-link">
  Java
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>mysql</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html" class="active sidebar-link"> mysql45讲笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第03、08讲-事务隔离" class="sidebar-link">第03、08讲 事务隔离</a></li><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第04、05、09讲-索引" class="sidebar-link">第04、05、09讲 索引</a></li><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第06、07讲-全局锁、表锁、行锁" class="sidebar-link">第06、07讲 全局锁、表锁、行锁</a></li><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第12讲-刷脏页" class="sidebar-link">第12讲 刷脏页</a></li><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第13讲-数据库表的空间回收" class="sidebar-link">第13讲 数据库表的空间回收</a></li><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第14讲-count" class="sidebar-link">第14讲 count(*)</a></li><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第20讲-幻读" class="sidebar-link">第20讲 幻读</a></li><li class="sidebar-sub-header"><a href="/Java-cc-4pm/mysql/ mysql45讲笔记.html#第22讲-饮鸠止渴-提高性能" class="sidebar-link">第22讲 ‘饮鸠止渴’提高性能</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql45讲"><a href="#mysql45讲" class="header-anchor">#</a> mysql45讲</h1> <h2 id="第03、08讲-事务隔离"><a href="#第03、08讲-事务隔离" class="header-anchor">#</a> 第03、08讲 事务隔离</h2> <p>多个事务同时执行 会导致 --&gt; 脏读，不可重复读，幻读等问题</p> <h3 id="隔离级别-解决脏读-幻读-不可重复读"><a href="#隔离级别-解决脏读-幻读-不可重复读" class="header-anchor">#</a> 隔离级别（解决脏读，幻读，不可重复读）</h3> <ul><li><strong>读未提交</strong> ：一个事务还没提交时，它做的变更就能被别的事务看到。</li> <li><strong>读提交</strong>：一个事务提交之后，它做的变更才会被其他事务看到。</li> <li>**可重复读：**一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。</li> <li><strong>串行化</strong>：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。</li></ul> <p>配置隔离级别为 “读提交”</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token string">'查看当前隔离级别'</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'transaction_isolation'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span>
<span class="token operator">|</span> Variable_name         <span class="token operator">|</span> <span class="token keyword">Value</span>           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span>
<span class="token operator">|</span> transaction_isolation <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------------+-----------------+</span>
</code></pre></div><h3 id="事务隔离的实现-多版本并发控制-mvcc"><a href="#事务隔离的实现-多版本并发控制-mvcc" class="header-anchor">#</a> 事务隔离的实现：多版本并发控制（MVCC）</h3> <p>每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通 过回滚操作，都可以得到前一个状态的值。
<img src="https://cdn.nlark.com/yuque/0/2022/png/22068508/1659332979409-c80ad8fa-818c-435f-a344-20d71dc64491.png#clientId=u4a1c72a4-1054-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=239&amp;id=u9dc62519&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=646&amp;originWidth=1178&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=354737&amp;status=done&amp;style=none&amp;taskId=u933ac72a-c055-4ef1-9caf-69bdd97decb&amp;title=&amp;width=435" alt="image.png">
长事务：存在很老的事务视图。大量占用存储空间，占用锁资源。</p> <h3 id="事务启动方式"><a href="#事务启动方式" class="header-anchor">#</a> 事务启动方式</h3> <ol><li>显示启动：begin 或 start transaction 提交 commit 回滚 rollback</li> <li>set autocommit = 0 不会自动提交</li></ol> <p>建议：在autocommit为1的情况下，用begin显式启动的事务，如果执行commit则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务。</p> <h3 id="避免长事务对业务的影响"><a href="#避免长事务对业务的影响" class="header-anchor">#</a> 避免长事务对业务的影响</h3> <ul><li>开发端
<ol><li>确认是否使用了set autocommit=0。把MySQL的 general_log开起来，然后随便跑一个业务逻辑，通过general_log的日志来确认。</li> <li>确认是否有不必要的只读事务。</li> <li>根据业务本身的预估，通过SETMAX_EXECUTION_TIME命令， 来控制每个语句执行的最长时间</li></ol></li> <li>数据库端
<ol><li>监控 information_schema.Innodb_trx表，设置长事务阈值，超过就报警/或者kill;</li> <li>Percona的pt-kill</li> <li>在业务功能测试阶段要求输出所有的general_log，分析日志行为提前发现问题;</li> <li>如果使用的是MySQL5.6或者更新版本，把innodb_undo_tablespaces设置成2(或更大的 值)。</li></ol></li></ul> <h3 id="事务隔离"><a href="#事务隔离" class="header-anchor">#</a> 事务隔离</h3> <ul><li>数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id。</li></ul> <p>InnoDB利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建 快照”的能力。</p> <ul><li>更新数据都是先读后写的，而这个读，只能读当前的 值，称为“当前读”(current read)。</li></ul> <p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以 外，有三种情况:</p> <ol><li>版本未提交，不可见;</li> <li>版本已提交，但是是在视图创建后提交的，不可见;</li> <li>版本已提交，而且是在视图创建前提交的，可见。</li></ol> <h2 id="第04、05、09讲-索引"><a href="#第04、05、09讲-索引" class="header-anchor">#</a> 第04、05、09讲 索引</h2> <p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</p> <h3 id="常见模型"><a href="#常见模型" class="header-anchor">#</a> 常见模型</h3> <ul><li>哈希表</li></ul> <p>哈希+链表，适用于只有等值查询的场景。如memcached及其他nosql引擎。</p> <ul><li>有序数组</li></ul> <p>数组，适用于等值查询和范围查询，静态存储引擎。更新效率不高。</p> <ul><li>搜索树</li> <li>跳表</li> <li>LSM树</li></ul> <p>数据库底层存储的核心就是基于这些数据模型的。
在MySQL中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。</p> <h3 id="innodb索引模型"><a href="#innodb索引模型" class="header-anchor">#</a> InnoDB索引模型</h3> <p>每一个索引在InnoDB里面对应一棵B+树。B+树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。
建表语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">create</span> <span class="token keyword">table</span> T<span class="token punctuation">(</span>
  id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>
  k <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>
  name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">index</span> <span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
</code></pre></div><p>根据叶子节点的内容，索引类型分为主键索引(聚簇索引)和非主键索引（二级索引）。</p> <ul><li>主键索引的叶子节点存的是整行数据</li> <li>非主键索引的叶子节点内容是主键的值，基于非主键索引的查询需要多扫描一棵索引树。（回表）</li></ul> <h3 id="索引维护"><a href="#索引维护" class="header-anchor">#</a> 索引维护</h3> <p>页分裂。性能受到影响。数据页的利用率收到影响。
页合并。
解决：
创建一个<strong>自增主键</strong>，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
这样非主键索引占用的空间最小。主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p> <h3 id="回表"><a href="#回表" class="header-anchor">#</a> 回表</h3> <p>回到主键索引树搜索的过程，我们称为回表。
由于查询结果所需要的数据只在主键索引上有，所以不得不回表。</p> <h3 id="覆盖索引"><a href="#覆盖索引" class="header-anchor">#</a> 覆盖索引</h3> <p>索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。
由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用 的性能优化手段。
索引字段的维护总是有代价的，在建立冗余索引来支持覆盖索引时就需要权衡考虑。</p> <h3 id="最左前缀原则"><a href="#最左前缀原则" class="header-anchor">#</a> 最左前缀原则</h3> <p><img src="https://cdn.nlark.com/yuque/0/2022/png/22068508/1659505363279-f2b6ceaf-5a96-48a5-b222-77e015015054.png#clientId=ue247b6ed-ab97-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=259&amp;id=u9522ba46&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=726&amp;originWidth=1238&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=980656&amp;status=done&amp;style=none&amp;taskId=u0dcc2a8d-71b8-4a7c-8f94-5674ae9e59e&amp;title=&amp;width=441" alt="image.png"> <code>where name like ‘张%’</code>，查找到第一个符合条件的记录是ID3，然后向后遍历， 直到不满足条件为止。</p> <blockquote><p>联合索引如何安排索引顺序？</p></blockquote> <p>优先考虑索引的复用能力。
其次考虑空间。</p> <h3 id="索引下推"><a href="#索引下推" class="header-anchor">#</a> 索引下推</h3> <p>有联合索引：<code>(name,age)</code>
SQL语句：<code>select * from tuser where name like '张%' and age = 10 and ismale = 1;</code></p> <ol><li><p>&quot;张&quot; 找到 ID3</p></li> <li></li> <li><p>5.6之前 ：回表，对比字段值</p></li> <li><p>5.6之后 ：索引下推，索引遍历过程中，对索引包含的字段做判断，直接过滤掉不满足条件的记录。减少回表次数。</p></li></ol> <h3 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="header-anchor">#</a> 普通索引和唯一索引</h3> <p><strong>查询过程</strong>：</p> <ul><li>普通索引：查到满足条件的第一个记录后，需要查找下一个记录，直到碰到不满足条件的记录。</li> <li>唯一索引：查到第一个满足条件的记录后，停止继续检索。</li></ul> <p>性能差距：微乎其微。
原因：InnoDB引擎是按数据页为单位来读写的。
<strong>change buffer</strong>：数据页更新时，若内存中有则直接更新，若没有，将更新操作缓存在change buffer中，查询需要访问数据页时，将数据页读入内存，然后执行change buffer中缓存的相关操作来保证数据的正确性。
<strong>merge触发机制</strong>：1. 访问数据页时 2. 后台线程定期merge 3. shutdown时
<strong>大小设置</strong>：change buffer用的是buffer pool里的内存，可以通过innodb_change_buffer_max_size参数设置，设置为50时，表示change buffer的大小最多只能占用buffer pool的50%。
<strong>适用场景</strong>：写多读少。原因：一次merge之前，change buffer记录的变更越多，收益越大。
若一次更新后伴随查询，则不应该使用，IO次数不会减少反而增加change buffer维护代价。
<strong>更新过程：</strong>
唯一索引下，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。所以没必要使用change buffer。
情况一：这个记录要更新的目标页在内存中。</p> <ul><li>唯一索引：找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束;</li> <li>普通索引：找到3和5之间的位置，插入这个值，语句执行结束。</li></ul> <p>情况二：要更新的目标页不在内存中。</p> <ul><li>唯一索引：需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束。</li> <li>普通索引：将更新记录在change buffer，语句执行结束。</li></ul> <p><strong>change buffer和redo log：</strong>
redo log将随机写IO转换成顺序写IO，change buffer是减少随机读IO的消耗。</p> <h3 id="选错索引"><a href="#选错索引" class="header-anchor">#</a> 选错索引</h3> <p>原因：优化器没能准确判断出<strong>扫描行数</strong>。
扫描行数的判断：索引的“区分度”，即索引上不同值的个数（基数）。个数越多区分度越好。
基数计算：采样统计。
解决：
<code>analyze table t</code>：重新统计索引信息</p> <ol><li><code>force index(a) ：让优化器强制使用a索引</code></li> <li>修改语句</li> <li>新建一个更合适的索引，或删掉误用的索引。</li></ol> <h3 id="字符串字段加索引"><a href="#字符串字段加索引" class="header-anchor">#</a> 字符串字段加索引</h3> <ul><li>创建完整索引</li> <li>前缀索引：区分度越高，效果越好</li></ul> <p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。
使用前缀索引就用不上覆盖索引对查询性能的优化
区分度不够时：</p> <ul><li>倒序存储</li> <li>使用hash字段：新建整数字段，保存校验码，同时在字段上建立索引，插入时先得到校验码填入这个新字段。由于存在冲突，所以查询where部分需要同时判断id_card是否相同。</li></ul> <h2 id="第06、07讲-全局锁、表锁、行锁"><a href="#第06、07讲-全局锁、表锁、行锁" class="header-anchor">#</a> 第06、07讲 全局锁、表锁、行锁</h2> <h3 id="全局锁"><a href="#全局锁" class="header-anchor">#</a> 全局锁</h3> <p>定义：对整个数据库实例加锁。
两种方式：</p> <ul><li>FLUSH TABLES WRITE READ LOCK</li> <li>set global readonly=true</li></ul> <p>建议FTWRL方式
原因：</p> <ol><li>readonly可能被用来做其他判断，比如主从库。</li> <li>异常处理机制差异：readonly异常时会保持readonly状态，导致长时间不可写。FTWRL异常时，mysql会自动释放全局锁。
使用场景：全库逻辑备份。
只读状态危险（不加–single-transaction时）：
主库备份：不能更新，业务停摆
从库备份：从库不能执行binlog，导致主从延迟
<strong>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性快照视图</strong>。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</li></ol> <h3 id="表级锁"><a href="#表级锁" class="header-anchor">#</a> 表级锁</h3> <ul><li>表锁 （不支持行锁时才会用到）</li></ul> <p>语法：加锁、lock tables ...read/write ；释放、unlock tables
注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p> <ul><li>元数据锁（meta date lock，MDL）</li></ul> <p>在访问一个表的时候会被自动加上，当对一个表做增删改查操作的时候，加MDL读锁;当要对表做结构变更操作的时候，加MDL写锁。</p> <ul><li>读锁之间不互斥</li> <li>读写锁之间，写锁之间互斥，保证表更表结构操作的安全性。</li></ul> <p>如何安全地给小表加字段?</p> <ol><li>解决长事务，暂停或kill掉。MySQL的information_schema 库的 innodb_trx表中可以查询正在执行的事务。</li> <li>若是热点表，请求频繁，kill不掉。考虑在alter table语句里面 设定等待时间。能拿到MDL写锁最好，拿不到先放弃，之后用重试命令重复过程。</li></ol> <h3 id="行锁"><a href="#行锁" class="header-anchor">#</a> 行锁</h3> <p>由各个引擎自己实现。MyISAM不支持行锁，Innodb支持。
在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是<strong>两阶段锁</strong>协议。
所以，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。
死锁：
并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致 这几个线程都进入无限等待的状态，称为死锁。
出现死锁后的策略：</p> <ul><li>直接进入等待，直到超时。超时时间可以通过参数 innodb_lock_wait_timeout来设置。默认开启且时间为50s。</li> <li>（推荐）发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事 务得以继续执行。将参数innodb_deadlock_detect设置为on（默认为on），表示开启这个逻辑。</li></ul> <p>解决热点行更新导致对的性能问题（假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级 ）：</p> <ul><li>确保不会出现死锁的前提下，临时关掉死锁检测。</li> <li>控制并发度。</li></ul> <h2 id="第12讲-刷脏页"><a href="#第12讲-刷脏页" class="header-anchor">#</a> 第12讲 刷脏页</h2> <p>脏页（内存数据页跟磁盘数据页内容不一致的时候） --&gt; flush（把内存里的数据写入磁盘的过程） --&gt;干净页（内存和磁盘上的数据页的内容一致）
<strong>flush触发时机</strong>：</p> <ul><li>innoDB的redo log写满了</li> <li>系统内存不足</li> <li>系统空闲时期</li> <li>mysql正常关闭时</li></ul> <p>InnoDB用缓冲池 (buffer pool)管理内存，<strong>缓冲池中的内存页有三种状态</strong>:
第一种是，还没有使用的;
第二种是，使用了并且是干净页;
第三种是，使用了并且是脏页。
<strong>刷脏页影响性能情况：</strong></p> <ol><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长;</li> <li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。</li></ol> <p><strong>InnoDB刷脏页控制策略：</strong> <code>innodb_io_capacit</code> 值设置为磁盘的IOPS  ： 让磁盘全力刷脏页
磁盘的IOPS可以通过fio工具测试
<strong>Innodb刷盘速度</strong>：脏页比例 + redo log写盘速度</p> <ol><li>innodb根据脏页比例根据算法计算出一个值，根据日志序号和checkpoint的差值根据算法计算一个值，取两者较大的记为R</li> <li>innodb按照R% * innodb_io_capacity</li></ol> <h2 id="第13讲-数据库表的空间回收"><a href="#第13讲-数据库表的空间回收" class="header-anchor">#</a> 第13讲 数据库表的空间回收</h2> <p>innodb表 = 表结构定义 + 数据
8.0以前：表结构存在.frm文件里
8.0之后：表结构系统数据表中</p> <h3 id="参数innodb-file-per-table"><a href="#参数innodb-file-per-table" class="header-anchor">#</a> 参数innodb_file_per_table</h3> <p>作用：控制表数据存在 共享表空间（off） or 成为一个单独.ibd文件（on）
5.6以后 默认为on。（推荐）</p> <ul><li>更容易管理。</li> <li>且通过drop命令可以删除文件。如果为off，表删除掉，空间并不会回收。</li></ul> <h3 id="数据删除流程"><a href="#数据删除流程" class="header-anchor">#</a> 数据删除流程</h3> <p>delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件 的大小是不会变的。并且数据页的复用跟记录的复用是不同的。不止是删除数据会造成空洞，插入数据也会。
结论：大量增删改的表，都可能存在空洞。</p> <h3 id="重建表"><a href="#重建表" class="header-anchor">#</a> 重建表</h3> <p>5.6之前：alter table A engine=InnoDB ；会造成数据丢失。
5.6之后：online DDL；重建表过程中，允许做增删改操作。</p> <p>如果要收缩一个表，只是delete掉表里面不用的数据的话，表文件的大小是 不会变的，你还要通过alter table命令重建表，才能达到表文件变小的目的。</p> <p>在重建表的时候，InnoDB不会把整张表占满，每个页留了1/16给后续的更新用。也就是说，其实重建表之后不是“最”紧凑的。</p> <h2 id="第14讲-count"><a href="#第14讲-count" class="header-anchor">#</a> 第14讲 count(*)</h2> <p>count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NULL，累计值就加1，否则不加。最后返回累计值。</p> <h3 id="count-实现方式"><a href="#count-实现方式" class="header-anchor">#</a> count(*)实现方式</h3> <ul><li>MyISAM 总行数存在了磁盘上，直接返回</li> <li>InnoDB 一行一行读，然后累计计数</li></ul> <p>由于MVCC的存在，同一时刻的多个查询，InnoDB表“应该返回多少行”的个数也是不确定的。
所以只能一行一行依次读进行判断。
优化：
MySQL优化器会找到最小的那棵树来遍历。在保证逻辑正 确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。
总结：</p> <ul><li>MyISAM表虽然count(*)很快，但是不支持事务;</li> <li>show table status命令虽然返回很快，但是不准确;</li> <li>InnoDB表直接count(*)会遍历全表，虽然结果准确，但会导致性能问题。</li></ul> <h3 id="自己计数"><a href="#自己计数" class="header-anchor">#</a> 自己计数</h3> <ul><li>缓存系统保存计数（Redis：可能会丢失更新</li> <li>数据库保存计数（把计数直接放到数据库里单独的一张计数表C中</li></ul> <h2 id="第20讲-幻读"><a href="#第20讲-幻读" class="header-anchor">#</a> 第20讲 幻读</h2> <ul><li>for update：在查询时,对这条数据进行加锁,避免其他用户以该表进行插入,修改或删除等操作,造成表的不一致性.</li></ul> <p>当前读。能读到所有已经提交的记录的最新值。
InnoDB默认是行级别的锁，当有明确指定的主键时候，是行级锁。否则是表级别。</p> <ul><li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li> <li>幻读仅专指“<strong>新插入的行</strong>”。</li></ul> <h3 id="幻读的问题"><a href="#幻读的问题" class="header-anchor">#</a> 幻读的问题</h3> <ul><li>语义破坏</li> <li>数据一致性</li></ul> <h3 id="解决-间隙锁"><a href="#解决-间隙锁" class="header-anchor">#</a> 解决--间隙锁</h3> <p>原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。
间隙锁：跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。
间隙锁+行锁 = next- key lock 一个前开后闭区间
间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。
间隙锁是在可重复读隔离级别下才会生效。
如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把binlog格式设置 为row。这也是现在不少公司使用的配置组合。</p> <h2 id="第22讲-饮鸠止渴-提高性能"><a href="#第22讲-饮鸠止渴-提高性能" class="header-anchor">#</a> 第22讲 ‘饮鸠止渴’提高性能</h2> <h3 id="短链接风暴"><a href="#短链接风暴" class="header-anchor">#</a> 短链接风暴</h3> <p>mysql建立连接需要：网络连接三次握手，登录权限判断，获得读写权限。
连接数上限：max_connections参数；超过时会拒绝连接。
连接数暴涨时：</p> <ol><li>处理掉占着连接但是不工作的线程。</li></ol> <ul><li>事先设置wait_timeout（空闲wait_timeout秒后直接断开连接）</li> <li>show processlist踢掉显示为sleep的线程
<ul><li>注意⚠️：查information_schema库的innodb_trx表（当前运行的所有事务）。先踢掉不在此表的线程。</li></ul></li></ul> <ol start="2"><li>减少连接过程的消耗。</li></ol> <ul><li>跳过权限验证：重启数据库，并使用-skip-grant-tables参数启动。</li></ul> <h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="header-anchor">#</a> 慢查询性能问题</h3> <h4 id="索引没有设计好"><a href="#索引没有设计好" class="header-anchor">#</a> 索引没有设计好</h4> <ul><li>紧急创建索引（主库A、备库B）
<ul><li>备库B执行set sql_log_bin=off; alter table；</li> <li>主备切换</li> <li>备库A执行相同语句</li></ul></li> <li>gh-ost</li></ul> <h4 id="sql语句没写好-18讲提到的情况"><a href="#sql语句没写好-18讲提到的情况" class="header-anchor">#</a> SQL语句没写好（18讲提到的情况）</h4> <ul><li>query_rewrite插件（可以把输入的一种语句改写成另外一种模式）</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 目的</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>
<span class="token comment">-- 改为</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">10000</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- 插入一条规则（注：我这张表在 employees 库中）</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> query_rewrite<span class="token punctuation">.</span>rewrite_rules<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> replacement<span class="token punctuation">,</span> pattern_database<span class="token punctuation">)</span> <span class="token keyword">values</span> 
<span class="token punctuation">(</span><span class="token string">&quot;select * from t where id + 1 = ? &quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;select * from t where id = ? - 1 &quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;employees&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
 <span class="token comment">-- 存储过程，是让插入的新规则生效，也就是我们说的“查询重写”。</span>
<span class="token keyword">call</span> query_rewrite<span class="token punctuation">.</span>flush_rewrite_rules<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">-- 查询规则表</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> query_rewrite<span class="token punctuation">.</span>rewrite_rules<span class="token punctuation">;</span>
</code></pre></div><h4 id="mysql选错索引-10讲提到的情况"><a href="#mysql选错索引-10讲提到的情况" class="header-anchor">#</a> Mysql选错索引（10讲提到的情况）</h4> <ul><li>使用查询重写功能，加上force index</li></ul> <h4 id="如何避免"><a href="#如何避免" class="header-anchor">#</a> 如何避免</h4> <ul><li>测试环境把慢查询日志 show log打开且 long_query_time = 0，确保每个语句都会被记录</li> <li>模拟线上数据，做一遍回归测试</li> <li>观察慢查询日志的输出，特别留意rows_examined字段是否与预期一致。</li></ul> <h3 id="qps突增问题"><a href="#qps突增问题" class="header-anchor">#</a> QPS突增问题</h3></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/Java-cc-4pm/assets/js/app.b4fa842c.js" defer></script><script src="/Java-cc-4pm/assets/js/2.eeb24f79.js" defer></script><script src="/Java-cc-4pm/assets/js/14.275ba392.js" defer></script>
  </body>
</html>
